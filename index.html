<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Carlos Calixto</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
  </head>
  <body>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        (function() {
          let isLocked = false;
          let pendingTargetIndex = null;
          let wheelAccumulation = 0;
          const ACCUM_THRESHOLD = 60; // px of wheel delta needed to trigger a step
          const MAX_DELTA_PER_EVENT = 120; // clamp extreme deltas per event
          const FALLBACK_UNLOCK_MS = 1000; // safety unlock

          const sections = Array.from(document.querySelectorAll('.container'));
          if (!sections.length) return;
          let currentIndex = 0;
          let touchStartY = 0;
          let touchStartTime = 0;
          let touchMoved = false;
          let touchAccumulation = 0;
          const TOUCH_ACCUM_THRESHOLD = 80; // px de movimento acumulado para trigger
          const MAX_TOUCH_DELTA_PER_EVENT = 100; // limita delta extremo por evento

          const scrollToIndex = (idx) => {
            const clamped = Math.max(0, Math.min(idx, sections.length - 1));
            currentIndex = clamped;
            sections[clamped].scrollIntoView({ behavior: 'smooth', block: 'start' });
          };

          const getNearestIndex = () => {
            let nearest = 0;
            let minDist = Infinity;
            const y = window.scrollY;
            sections.forEach((el, i) => {
              const top = el.offsetTop;
              const dist = Math.abs(top - y);
              if (dist < minDist) { minDist = dist; nearest = i; }
            });
            return nearest;
          };

          const isSectionSnapped = (idx) => {
            const el = sections[idx];
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            // Consider snapped when top is close to viewport top
            return Math.abs(rect.top) < 6;
          };

          // Touch event handlers for mobile
          const handleTouchStart = (e) => {
            if (isLocked) return;
            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
            touchMoved = false;
          };

          const handleTouchMove = (e) => {
            if (isLocked || !touchStartY) return;
            
            const currentY = e.touches[0].clientY;
            const deltaY = touchStartY - currentY;
            const deltaTime = Date.now() - touchStartTime;
            
            // Clamp extreme deltas and accumulate (similar to wheel logic)
            const clampedDelta = Math.max(-MAX_TOUCH_DELTA_PER_EVENT, Math.min(deltaY, MAX_TOUCH_DELTA_PER_EVENT));
            touchAccumulation += clampedDelta;
            
            // Only trigger if accumulated enough movement and not already triggered
            if (!touchMoved && Math.abs(touchAccumulation) >= TOUCH_ACCUM_THRESHOLD && deltaTime < 500) {
              touchMoved = true;
              const direction = touchAccumulation > 0 ? 1 : -1;
              touchAccumulation = 0; // consume one step only
              const base = getNearestIndex();
              const target = Math.max(0, Math.min(base + direction, sections.length - 1));
              if (target !== base) {
                isLocked = true;
                pendingTargetIndex = target;
                scrollToIndex(target);
                // Fallback unlock in case observer misses
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            }
          };

          const handleTouchEnd = (e) => {
            // Reset touch state
            touchStartY = 0;
            touchStartTime = 0;
            touchMoved = false;
            touchAccumulation = 0; // reset accumulation for next touch
          };

          // Observe snapping completion to release lock
          const observer = new IntersectionObserver((entries) => {
            if (pendingTargetIndex == null) return;
            entries.forEach((entry) => {
              if (entry.isIntersecting && sections[pendingTargetIndex] === entry.target) {
                if (isSectionSnapped(pendingTargetIndex)) {
                  isLocked = false;
                  pendingTargetIndex = null;
                }
              }
            });
          }, { threshold: [0, 0.5, 1] });
          sections.forEach(s => observer.observe(s));

          // Add touch event listeners
          document.addEventListener('touchstart', handleTouchStart, { passive: false });
          document.addEventListener('touchmove', handleTouchMove, { passive: false });
          document.addEventListener('touchend', handleTouchEnd, { passive: false });

          window.addEventListener('wheel', (e) => {
            // Always prevent default to avoid native momentum interfering
            e.preventDefault();
            if (isLocked) return;

            // Clamp extreme deltas and accumulate
            const clampedDelta = Math.max(-MAX_DELTA_PER_EVENT, Math.min(e.deltaY, MAX_DELTA_PER_EVENT));
            wheelAccumulation += clampedDelta;

            if (Math.abs(wheelAccumulation) >= ACCUM_THRESHOLD) {
              const direction = wheelAccumulation > 0 ? 1 : -1;
              wheelAccumulation = 0; // consume one step only
              const base = getNearestIndex();
              const target = Math.max(0, Math.min(base + direction, sections.length - 1));
              if (target !== base) {
                isLocked = true;
                pendingTargetIndex = target;
                scrollToIndex(target);
                // Fallback unlock in case observer misses
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            }
          }, { passive: false });

          // Also support keyboard arrows/PageUp/PageDown
          window.addEventListener('keydown', (e) => {
            const keysDown = ['ArrowDown', 'PageDown', ' '];
            const keysUp = ['ArrowUp', 'PageUp'];
            if (isLocked) return;
            if (keysDown.includes(e.key)) {
              e.preventDefault();
              const base = getNearestIndex();
              const target = Math.min(base + 1, sections.length - 1);
              if (target !== base) {
                isLocked = true; pendingTargetIndex = target;
                scrollToIndex(target);
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            } else if (keysUp.includes(e.key)) {
              e.preventDefault();
              const base = getNearestIndex();
              const target = Math.max(base - 1, 0);
              if (target !== base) {
                isLocked = true; pendingTargetIndex = target;
                scrollToIndex(target);
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            }
          });
        })();
      });
    </script>
    <div class="container">
      <div class="card">
        <div class="me">
          <img src="img/me 01.png" alt="Carlos Calixto">
          <h1>Carlos Calixto</h1>
          <p class="subtitle">Copywriter</p>
          <!--ADICIONAR AQUI 3 REDES SOCIAIS, PEQUENININHAS, linkedin, discord, x-->
        </div>
        <div class="text">
          <p>Se você é um empreendedor de visão e quer textos persuasivos de verdade, continue a leitura. Pois vou entregar os unicos 3 pilares, que podem te levar ao sucesso no persuasão.</p>
          <!-- procurar uma fonte com um tom mais publicitário. ta mt secão-->
        </div>
        
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <!-- <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M480-80q-26 0-47-12.5T400-126q-33 0-56.5-23.5T320-206v-142q-59-39-94.5-103T190-590q0-121 84.5-205.5T480-880q121 0 205.5 84.5T770-590q0 77-35.5 140T640-348v142q0 33-23.5 56.5T560-126q-12 21-33 33.5T480-80Zm-80-126h160v-36H400v36Zm0-76h160v-38H400v38Zm-8-118h58v-108l-88-88 42-42 76 76 76-76 42 42-88 88v108h58q54-26 88-76.5T690-590q0-88-61-149t-149-61q-88 0-149 61t-61 149q0 63 34 113.5t88 76.5Zm88-162Zm0-38Z"/></svg> -->
        <h1>Clareza</h1>
        <p class="subtitle"> "A simplicidade é o mais alto grau de sofistificação" - Leo da Vinci, XVI dc.</p>
        <p class="sub-text">  Veja, a mente humana tem medo do que ela não consegue entender. Portanto quanto mais dificil de entender for a sua mensagem, menor a chance de vender. Seja ousado, mas seja simples, e você verá chover dinheiro.</p>
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <h1>Emoção</h1>
        <p class="subtitle"> "As pessoas compram na emoção e justificam a compra com a lógica. " <br> - Jordan Belfort, 2017.</p>
        <p class="sub-text"> As pessoas não compram por necessidade empreendedor, compram por desejo, por isso seu combustivel numero um são as emoções. Pare de vender agua na praia. Começe a vender refrescância no deserto. Faça isso, e você se espantará com o resultado.</p>
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <h1>Confiança</h1>
        <p class="subtitle"> "As pessoas compram de quem elas confiam" <br> - Mark Jewell, 2021.</p>
        <p class="sub-text"> Pareçe um cliche, mas não é, e muitos torram grana por não entenderem isso. Vender é se relacionar, e desde que eramos nômades, só nos relacionamos com quem verdadeiramente confiamos. Seja por meio da construção de audiência, ou do branding da publicidade tradicional, jamais subestime o poder da boa e velha confiança.</p>
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <h1>Eae Gostou?</h1>
        <p class="subtitle"> "Foi um prazer ter você aqui" <br> - Carlos Calixto, 2025.</p>
        <p class="sub-text"> Poderiamos ter falado de várias outras coisas, story telling, gatilhos mentais, funils de vendas. Mas assim como toda arvore que não tem raiz, um dia cai, assim imagino que nossas tecnicas sem os princípios, não vão florecer no maximo do seu potencial.</p>

        <p class="sub-text"> <br> Agora não se esqueça de conferir o nosso portifolio, e explodir as suas vendas com nossos serviços. Até a próxima empreendedor, sucesso! 🚀</p>
      </div>
    </div>
    <br>
    <div class="separate">
      <button class="portfolio-btn">Conferir Portfólio</button>
    </div>

    
    
  </body>
</html>


