<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Carlos Calixto</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
  </head>
  <body>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        (function() {
          let isLocked = false;
          let pendingTargetIndex = null;
          let wheelAccumulation = 0;
          const ACCUM_THRESHOLD = 60; // px of wheel delta needed to trigger a step
          const MAX_DELTA_PER_EVENT = 120; // clamp extreme deltas per event
          const FALLBACK_UNLOCK_MS = 1000; // safety unlock

          const sections = Array.from(document.querySelectorAll('.container'));
          if (!sections.length) return;
          let currentIndex = 0;
          let touchStartY = 0;
          let touchStartTime = 0;
          let touchMoved = false;
          let touchAccumulation = 0;
          const TOUCH_ACCUM_THRESHOLD = 80; // px de movimento acumulado para trigger
          const MAX_TOUCH_DELTA_PER_EVENT = 100; // limita delta extremo por evento

          const scrollToIndex = (idx) => {
            const clamped = Math.max(0, Math.min(idx, sections.length - 1));
            currentIndex = clamped;
            sections[clamped].scrollIntoView({ behavior: 'smooth', block: 'start' });
          };

          const getNearestIndex = () => {
            let nearest = 0;
            let minDist = Infinity;
            const y = window.scrollY;
            sections.forEach((el, i) => {
              const top = el.offsetTop;
              const dist = Math.abs(top - y);
              if (dist < minDist) { minDist = dist; nearest = i; }
            });
            return nearest;
          };

          const isSectionSnapped = (idx) => {
            const el = sections[idx];
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            // Consider snapped when top is close to viewport top
            return Math.abs(rect.top) < 6;
          };

          // Touch event handlers for mobile
          const handleTouchStart = (e) => {
            if (isLocked) return;
            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
            touchMoved = false;
          };

          const handleTouchMove = (e) => {
            if (isLocked || !touchStartY) return;
            
            const currentY = e.touches[0].clientY;
            const deltaY = touchStartY - currentY;
            const deltaTime = Date.now() - touchStartTime;
            
            // Clamp extreme deltas and accumulate (similar to wheel logic)
            const clampedDelta = Math.max(-MAX_TOUCH_DELTA_PER_EVENT, Math.min(deltaY, MAX_TOUCH_DELTA_PER_EVENT));
            touchAccumulation += clampedDelta;
            
            // Only trigger if accumulated enough movement and not already triggered
            if (!touchMoved && Math.abs(touchAccumulation) >= TOUCH_ACCUM_THRESHOLD && deltaTime < 500) {
              touchMoved = true;
              const direction = touchAccumulation > 0 ? 1 : -1;
              touchAccumulation = 0; // consume one step only
              const base = getNearestIndex();
              const target = Math.max(0, Math.min(base + direction, sections.length - 1));
              if (target !== base) {
                isLocked = true;
                pendingTargetIndex = target;
                scrollToIndex(target);
                // Fallback unlock in case observer misses
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            }
          };

          const handleTouchEnd = (e) => {
            // Reset touch state
            touchStartY = 0;
            touchStartTime = 0;
            touchMoved = false;
            touchAccumulation = 0; // reset accumulation for next touch
          };

          // Observe snapping completion to release lock
          const observer = new IntersectionObserver((entries) => {
            if (pendingTargetIndex == null) return;
            entries.forEach((entry) => {
              if (entry.isIntersecting && sections[pendingTargetIndex] === entry.target) {
                if (isSectionSnapped(pendingTargetIndex)) {
                  isLocked = false;
                  pendingTargetIndex = null;
                }
              }
            });
          }, { threshold: [0, 0.5, 1] });
          sections.forEach(s => observer.observe(s));

          // Add touch event listeners
          document.addEventListener('touchstart', handleTouchStart, { passive: false });
          document.addEventListener('touchmove', handleTouchMove, { passive: false });
          document.addEventListener('touchend', handleTouchEnd, { passive: false });

          window.addEventListener('wheel', (e) => {
            // Always prevent default to avoid native momentum interfering
            e.preventDefault();
            if (isLocked) return;

            // Clamp extreme deltas and accumulate
            const clampedDelta = Math.max(-MAX_DELTA_PER_EVENT, Math.min(e.deltaY, MAX_DELTA_PER_EVENT));
            wheelAccumulation += clampedDelta;

            if (Math.abs(wheelAccumulation) >= ACCUM_THRESHOLD) {
              const direction = wheelAccumulation > 0 ? 1 : -1;
              wheelAccumulation = 0; // consume one step only
              const base = getNearestIndex();
              const target = Math.max(0, Math.min(base + direction, sections.length - 1));
              if (target !== base) {
                isLocked = true;
                pendingTargetIndex = target;
                scrollToIndex(target);
                // Fallback unlock in case observer misses
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            }
          }, { passive: false });

          // Also support keyboard arrows/PageUp/PageDown
          window.addEventListener('keydown', (e) => {
            const keysDown = ['ArrowDown', 'PageDown', ' '];
            const keysUp = ['ArrowUp', 'PageUp'];
            if (isLocked) return;
            if (keysDown.includes(e.key)) {
              e.preventDefault();
              const base = getNearestIndex();
              const target = Math.min(base + 1, sections.length - 1);
              if (target !== base) {
                isLocked = true; pendingTargetIndex = target;
                scrollToIndex(target);
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            } else if (keysUp.includes(e.key)) {
              e.preventDefault();
              const base = getNearestIndex();
              const target = Math.max(base - 1, 0);
              if (target !== base) {
                isLocked = true; pendingTargetIndex = target;
                scrollToIndex(target);
                setTimeout(() => { if (isLocked) { isLocked = false; pendingTargetIndex = null; } }, FALLBACK_UNLOCK_MS);
              }
            }
          });
        })();
      });
    </script>
    <div class="container">
      <div class="card">
        <div class="me">
          <img src="img/me 01.png" alt="Carlos Calixto">
          <h1>Carlos Calixto</h1>
          <p class="subtitle">Copywriter</p>
          <!--ADICIONAR AQUI 3 REDES SOCIAIS, PEQUENININHAS, linkedin, discord, x-->
        </div>
        <div class="text">
          <p>Se voc√™ √© um empreendedor de vis√£o e quer textos persuasivos de verdade, continue a leitura. Pois vou entregar os unicos 3 pilares, que podem te levar ao sucesso no persuas√£o.</p>
          <!-- procurar uma fonte com um tom mais publicit√°rio. ta mt sec√£o-->
        </div>
        
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <!-- <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#434343"><path d="M480-80q-26 0-47-12.5T400-126q-33 0-56.5-23.5T320-206v-142q-59-39-94.5-103T190-590q0-121 84.5-205.5T480-880q121 0 205.5 84.5T770-590q0 77-35.5 140T640-348v142q0 33-23.5 56.5T560-126q-12 21-33 33.5T480-80Zm-80-126h160v-36H400v36Zm0-76h160v-38H400v38Zm-8-118h58v-108l-88-88 42-42 76 76 76-76 42 42-88 88v108h58q54-26 88-76.5T690-590q0-88-61-149t-149-61q-88 0-149 61t-61 149q0 63 34 113.5t88 76.5Zm88-162Zm0-38Z"/></svg> -->
        <h1>Clareza</h1>
        <p class="subtitle"> "A simplicidade √© o mais alto grau de sofistifica√ß√£o" - Leo da Vinci, XVI dc.</p>
        <p class="sub-text">  Veja, a mente humana tem medo do que ela n√£o consegue entender. Portanto quanto mais dificil de entender for a sua mensagem, menor a chance de vender. Seja ousado, mas seja simples, e voc√™ ver√° chover dinheiro.</p>
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <h1>Emo√ß√£o</h1>
        <p class="subtitle"> "As pessoas compram na emo√ß√£o e justificam a compra com a l√≥gica. " <br> - Jordan Belfort, 2017.</p>
        <p class="sub-text"> As pessoas n√£o compram por necessidade empreendedor, compram por desejo, por isso seu combustivel numero um s√£o as emo√ß√µes. Pare de vender agua na praia. Come√ße a vender refresc√¢ncia no deserto. Fa√ßa isso, e voc√™ se espantar√° com o resultado.</p>
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <h1>Confian√ßa</h1>
        <p class="subtitle"> "As pessoas compram de quem elas confiam" <br> - Mark Jewell, 2021.</p>
        <p class="sub-text"> Pare√ße um cliche, mas n√£o √©, e muitos torram grana por n√£o entenderem isso. Vender √© se relacionar, e desde que eramos n√¥mades, s√≥ nos relacionamos com quem verdadeiramente confiamos. Seja por meio da constru√ß√£o de audi√™ncia, ou do branding da publicidade tradicional, jamais subestime o poder da boa e velha confian√ßa.</p>
      </div>
    </div>

    <div class="separate">
      <img style="width:1rem;margin-top:2rem;" src="img/arrow-down-thin-circle-outline.svg">
    </div>

    <div class="container">
      <div class="card">
        <h1>Eae Gostou?</h1>
        <p class="subtitle"> "Foi um prazer ter voc√™ aqui" <br> - Carlos Calixto, 2025.</p>
        <p class="sub-text"> Poderiamos ter falado de v√°rias outras coisas, story telling, gatilhos mentais, funils de vendas. Mas assim como toda arvore que n√£o tem raiz, um dia cai, assim imagino que nossas tecnicas sem os princ√≠pios, n√£o v√£o florecer no maximo do seu potencial.</p>

        <p class="sub-text"> <br> Agora n√£o se esque√ßa de conferir o nosso portifolio, e explodir as suas vendas com nossos servi√ßos. At√© a pr√≥xima empreendedor, sucesso! üöÄ</p>
      </div>
    </div>
    <br>
    <div class="separate">
      <button class="portfolio-btn">Conferir Portf√≥lio</button>
    </div>

    
    
  </body>
</html>


